---
title: "Dynamic Programming"
format: html
toc: true
description: "Master dynamic programming techniques and patterns"
date: "2025-12-31"
execute:
  echo: false
  warning: false
---

```{=html}
<div class="hero-section fade-in">
  <h1>Dynamic Programming</h1>
  <p class="lead">Breaking complex problems down. Mastering the art of memoization and tabulation.</p>
</div>
```

# Dynamic Programming: Taming the Beast
 
 DP was the boss battle of my DSA journey. It felt like magic until I realized it's just "smart recursion".
 
 **My realization:** Don't repeat yourself. If you've solved a subproblem, save the answer! That's it. That's the whole trick.


Dynamic Programming (DP) is a method for solving complex problems by breaking them down into simpler subproblems. It's particularly useful for optimization problems where the solution can be constructed from solutions to overlapping subproblems.

## Core Concepts

### 1. Overlapping Subproblems
- Problems that can be broken down into smaller subproblems
- Solutions to subproblems are reused multiple times
- Example: Fibonacci sequence

### 2. Optimal Substructure
- An optimal solution can be constructed from optimal solutions to its subproblems
- Example: Shortest path in a graph

## Approaches

### 1. Top-down (Memoization)
```python
def fib(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 2:
        return 1
    memo[n] = fib(n-1, memo) + fib(n-2, memo)
    return memo[n]
```

### 2. Bottom-up (Tabulation)
```python
def fib(n):
    if n <= 2:
        return 1
    dp = [0] * (n + 1)
    dp[1] = dp[2] = 1
    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```

## Common DP Patterns

### 1. 0/1 Knapsack
```python
def knapsack(weights, values, capacity):
    n = len(weights)
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for w in range(1, capacity + 1):
            if weights[i-1] <= w:
                dp[i][w] = max(values[i-1] + dp[i-1][w-weights[i-1]], dp[i-1][w])
            else:
                dp[i][w] = dp[i-1][w]
    
    return dp[n][capacity]
```

### 2. Longest Common Subsequence (LCS)
```python
def lcs(text1, text2):
    m, n = len(text1), len(text2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if text1[i-1] == text2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]
```

### 3. Coin Change
```python
def coinChange(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    
    for coin in coins:
        for i in range(coin, amount + 1):
            dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1
```

## Common Problems
1. [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)
2. [House Robber](https://leetcode.com/problems/house-robber/)
3. [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)
4. [Word Break](https://leetcode.com/problems/word-break/)
5. [Unique Paths](https://leetcode.com/problems/unique-paths/)

## Time Complexity
| Problem Type | Time Complexity | Space Complexity |
|--------------|-----------------|------------------|
| 1D DP        | O(n)            | O(n) or O(1)     |
| 2D DP        | O(m*n)          | O(m*n) or O(n)   |
| Knapsack     | O(n*W)          | O(n*W) or O(W)   |
| LCS          | O(m*n)          | O(m*n) or O(n)   |

## Tips for Interviews
1. Start with a recursive solution first
2. Identify the base cases
3. Look for overlapping subproblems
4. Decide between top-down and bottom-up approach
5. Optimize space when possible
6. Practice drawing the DP table for better visualization
