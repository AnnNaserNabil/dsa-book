---
title: "Mastering DSA: Essential Problem-Solving Patterns with Examples"
description: "A comprehensive guide to common DSA patterns with 5 examples for each pattern"
date: 2025-12-31
author: "DSA Blog Team"
image: images/dsa-patterns.jpg
categories: ["Data Structures", "Algorithms", "Problem Solving"]
format: 
  html:
    code-fold: true
    code-tools: true
    code-line-numbers: true
---

## Introduction

Understanding common problem-solving patterns is crucial for efficiently tackling coding interview questions and competitive programming challenges. In this post, we'll explore essential DSA patterns with 5 examples for each pattern to help you recognize and apply them effectively.

## 1. Sliding Window

The sliding window technique is used to solve problems involving arrays or lists where we need to find a subarray or substring that meets certain conditions.

### Example 1: Maximum Sum Subarray of Size K
```python
def max_subarray_sum(arr, k):
    max_sum = window_sum = sum(arr[:k])
    for i in range(len(arr) - k):
        window_sum = window_sum - arr[i] + arr[i + k]
        max_sum = max(max_sum, window_sum)
    return max_sum
```

### Example 2: Longest Substring with K Distinct Characters
### Example 3: Fruits into Baskets
### Example 4: No-repeat Substring
### Example 5: Longest Substring with Same Letters after Replacement

## 2. Two Pointers

Two pointers technique is useful for searching pairs in a sorted array or linked list.

### Example 1: Pair with Target Sum
```python
def pair_with_target_sum(arr, target):
    left, right = 0, len(arr) - 1
    while left < right:
        current_sum = arr[left] + arr[right]
        if current_sum == target:
            return [left, right]
        if current_sum < target:
            left += 1
        else:
            right -= 1
    return [-1, -1]
```

### Example 2: Remove Duplicates from Sorted Array
### Example 3: Squaring a Sorted Array
### Example 4: Triplet Sum to Zero
### Example 5: Dutch National Flag Problem

## 3. Fast & Slow Pointers

This pattern is useful for cycle detection and finding the middle of a linked list.

### Example 1: Linked List Cycle
```python
def has_cycle(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            return True
    return False
```

### Example 2: Middle of the Linked List
### Example 3: Happy Number
### Example 4: Palindrome Linked List
### Example 5: Cycle in a Circular Array

## 4. Merge Intervals

This pattern is useful for dealing with overlapping intervals.

### Example 1: Merge Intervals
```python
def merge(intervals):
    if not intervals:
        return []
    
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    
    for current in intervals[1:]:
        last = merged[-1]
        if current[0] <= last[1]:
            last[1] = max(last[1], current[1])
        else:
            merged.append(current)
    
    return merged
```

### Example 2: Insert Interval
### Example 3: Intervals Intersection
### Example 4: Minimum Meeting Rooms
### Example 5: Maximum CPU Load

## 5. Subsets

This pattern is useful for finding all possible combinations or permutations of a set.

### Example 1: Subsets
```python
def subsets(nums):
    result = []
    def backtrack(start, path):
        result.append(path.copy())
        for i in range(start, len(nums)):
            path.append(nums[i])
            backtrack(i + 1, path)
            path.pop()
    
    backtrack(0, [])
    return result
```

### Example 2: Subsets With Duplicates
### Example 3: Permutations
### Example 4: String Permutations by Changing Case
### Example 5: Balanced Parentheses

## 6. Modified Binary Search

### Example 1: Order-agnostic Binary Search
```python
def binary_search(arr, key):
    start, end = 0, len(arr) - 1
    is_ascending = arr[start] < arr[end]
    
    while start <= end:
        mid = start + (end - start) // 2
        
        if arr[mid] == key:
            return mid
            
        if is_ascending:
            if key < arr[mid]:
                end = mid - 1
            else:
                start = mid + 1
        else:
            if key > arr[mid]:
                end = mid - 1
            else:
                start = mid + 1
    
    return -1
```

### Example 2: Ceiling of a Number
### Example 3: Next Letter
### Example 4: Number Range
### Example 5: Search in Rotated Array

## 7. Top K Elements

### Example 1: Top K Frequent Numbers
```python
import heapq
from collections import Counter

def top_k_frequent(nums, k):
    count = Counter(nums)
    return heapq.nlargest(k, count.keys(), key=count.get)
```

### Example 2: Kth Largest Element in a Stream
### Example 3: K Closest Points to Origin
### Example 4: Connect Ropes
### Example 5: Top K Frequent Words

## 8. K-way Merge

### Example 1: Merge K Sorted Lists
```python
import heapq

def merge_k_lists(lists):
    min_heap = []
    
    # Add first element of each list to the min heap
    for i in range(len(lists)):
        if lists[i]:
            heapq.heappush(min_heap, (lists[i][0], i, 0))
    
    result = []
    while min_heap:
        val, list_idx, element_idx = heapq.heappop(min_heap)
        result.append(val)
        
        if element_idx + 1 < len(lists[list_idx]):
            heapq.heappush(min_heap, (lists[list_idx][element_idx + 1], list_idx, element_idx + 1))
    
    return result
```

### Example 2: Kth Smallest Number in M Sorted Lists
### Example 3: Kth Smallest Number in a Sorted Matrix
### Example 4: Smallest Number Range
### Example 5: K Pairs with Largest Sums

## 9. Topological Sort

### Example 1: Topological Sort
```python
from collections import deque

def topological_sort(vertices, edges):
    in_degree = {i: 0 for i in range(vertices)}
    graph = {i: [] for i in range(vertices)}
    
    for edge in edges:
        parent, child = edge[0], edge[1]
        graph[parent].append(child)
        in_degree[child] += 1
    
    sources = deque()
    for key in in_degree:
        if in_degree[key] == 0:
            sources.append(key)
    
    sorted_order = []
    while sources:
        vertex = sources.popleft()
        sorted_order.append(vertex)
        for child in graph[vertex]:
            in_degree[child] -= 1
            if in_degree[child] == 0:
                sources.append(child)
    
    if len(sorted_order) != vertices:
        return []  # Cycle exists
    
    return sorted_order
```

### Example 2: Task Scheduling
### Example 3: All Tasks Scheduling Orders
### Example 4: Alien Dictionary
### Example 5: Minimum Height Trees

## 10. Dynamic Programming

### Example 1: Fibonacci Numbers
```python
def fib(n):
    if n <= 1:
        return n
    
    dp = [0] * (n + 1)
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    
    return dp[n]
```

### Example 2: 0/1 Knapsack
### Example 3: Longest Common Subsequence
### Example 4: Longest Increasing Subsequence
### Example 5: Edit Distance

## Conclusion

Mastering these patterns will significantly improve your problem-solving skills for coding interviews and competitive programming. Practice is key to recognizing which pattern to apply to a given problem. Remember that many problems might require a combination of these patterns.

### Additional Resources
- [LeetCode Patterns](https://seanprashad.com/leetcode-patterns/)
- [Grokking the Coding Interview](https://www.educative.io/courses/grokking-the-coding-interview)
- [NeetCode.io](https://neetcode.io/)

Happy coding! ðŸš€
